<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SymbolicNeuralNetworks.jl</title><meta name="title" content="Home · SymbolicNeuralNetworks.jl"/><meta property="og:title" content="Home · SymbolicNeuralNetworks.jl"/><meta property="twitter:title" content="Home · SymbolicNeuralNetworks.jl"/><meta name="description" content="Documentation for SymbolicNeuralNetworks.jl."/><meta property="og:description" content="Documentation for SymbolicNeuralNetworks.jl."/><meta property="twitter:description" content="Documentation for SymbolicNeuralNetworks.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SymbolicNeuralNetworks.jl/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SymbolicNeuralNetworks.jl/"/><link rel="canonical" href="https://JuliaGNI.github.io/SymbolicNeuralNetworks.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SymbolicNeuralNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="symbolic_neural_networks/">Vanilla Symbolic Neural Network</a></li><li><a class="tocitem" href="double_derivative/">Double Derivative</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SymbolicNeuralNetworks"><a class="docs-heading-anchor" href="#SymbolicNeuralNetworks">SymbolicNeuralNetworks</a><a id="SymbolicNeuralNetworks-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicNeuralNetworks" title="Permalink"></a></h1><p><code>SymbolicNeuralNetworks</code> is a library for creating symbolic representations of relatively small neural networks on whose basis more complicated expressions can be build. It should mostly be used together with other packages like <a href="https://github.com/JuliaGNI/GeometricMachineLearning.jl"><code>GeometricMachineLearning</code></a> and <a href="https://github.com/JuliaGNI/GeometricIntegrators.jl"><code>GeometricIntegrators</code></a>.</p><ul><li><a href="#SymbolicNeuralNetworks.Derivative"><code>SymbolicNeuralNetworks.Derivative</code></a></li><li><a href="#SymbolicNeuralNetworks.Gradient"><code>SymbolicNeuralNetworks.Gradient</code></a></li><li><a href="#SymbolicNeuralNetworks.HNNLoss"><code>SymbolicNeuralNetworks.HNNLoss</code></a></li><li><a href="#SymbolicNeuralNetworks.HamiltonianSymbolicNeuralNetwork"><code>SymbolicNeuralNetworks.HamiltonianSymbolicNeuralNetwork</code></a></li><li><a href="#SymbolicNeuralNetworks.Jacobian"><code>SymbolicNeuralNetworks.Jacobian</code></a></li><li><a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetworks.SymbolicNeuralNetwork</code></a></li><li><a href="#SymbolicNeuralNetworks.SymbolicPullback"><code>SymbolicNeuralNetworks.SymbolicPullback</code></a></li><li><a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_contents</code></a></li><li><a href="#SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_params</code></a></li><li><a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer</code></a></li><li><a href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer2</code></a></li><li><a href="#SymbolicNeuralNetworks._reduce_code-Tuple{Expr}"><code>SymbolicNeuralNetworks._reduce_code</code></a></li><li><a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a></li><li><a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Any, AbstractSymbolicNeuralNetwork, Any}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.derivative-Tuple{SymbolicNeuralNetworks.Gradient}"><code>SymbolicNeuralNetworks.derivative</code></a></li><li><a href="#SymbolicNeuralNetworks.evaluate_equation-NTuple{5, Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}}"><code>SymbolicNeuralNetworks.evaluate_equation</code></a></li><li><a href="#SymbolicNeuralNetworks.evaluate_equations-Tuple{NamedTuple, Vararg{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, 4}}"><code>SymbolicNeuralNetworks.evaluate_equations</code></a></li><li><a href="#SymbolicNeuralNetworks.evaluate_equations-Tuple{NamedTuple, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.evaluate_equations</code></a></li><li><a href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_create_array</code></a></li><li><a href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_map_reduce</code></a></li><li><a href="#SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.function_valued_parameters</code></a></li><li><a href="#SymbolicNeuralNetworks.make_kernel-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel</code></a></li><li><a href="#SymbolicNeuralNetworks.make_kernel2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel2</code></a></li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments</code></a></li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments2</code></a></li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments</code></a></li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments2</code></a></li><li><a href="#SymbolicNeuralNetworks.substitute_gradient-Tuple{Any, Any, Any}"><code>SymbolicNeuralNetworks.substitute_gradient</code></a></li><li><a href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.symbolic_pullback</code></a></li><li><a href="#SymbolicNeuralNetworks.symbolicparameters-Tuple{AbstractNeuralNetworks.Model}"><code>SymbolicNeuralNetworks.symbolicparameters</code></a></li><li><a href="#SymbolicNeuralNetworks.vector_field-Tuple{HamiltonianSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.vector_field</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.Derivative" href="#SymbolicNeuralNetworks.Derivative"><code>SymbolicNeuralNetworks.Derivative</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Derivative</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/derivatives/derivative.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.Gradient" href="#SymbolicNeuralNetworks.Gradient"><code>SymbolicNeuralNetworks.Gradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient &lt;: Derivative</code></pre><p>Computes and stores the gradient of a symbolic function with respect to the parameters of a <a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetwork</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Gradient(output, nn)</code></pre><p>Differentiate the symbolic <code>output</code> with respect to the parameters of <code>nn</code>.</p><pre><code class="nohighlight hljs">Gradient(nn)</code></pre><p>Compute the symbolic output of <code>nn</code> and differentiate it with respect to the parameters of <code>nn</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: SymbolicNeuralNetwork, Gradient, derivative
using AbstractNeuralNetworks
using Latexify: latexify

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
(Gradient(nn) |&gt; derivative)[1].L1.b |&gt; latexify

# output

L&quot;\begin{equation}
\left[
\begin{array}{c}
1 - \tanh^{2}\left( \mathtt{b\_1}_{1} + \mathtt{W\_1}_{1,1} \mathtt{sinput}_{1} + \mathtt{W\_1}_{1,2} \mathtt{sinput}_{2} \right) \\
\end{array}
\right]
\end{equation}
&quot;</code></pre><p><strong>Implementation</strong></p><p>Internally the constructors are using <a href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>symbolic_pullback</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/derivatives/gradient.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.HNNLoss" href="#SymbolicNeuralNetworks.HNNLoss"><code>SymbolicNeuralNetworks.HNNLoss</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HNNLoss &lt;: NetworkLoss</code></pre><p>The loss for a Hamiltonian neural network.</p><p><strong>Constructor</strong></p><p>This can be called with an instance of <a href="#SymbolicNeuralNetworks.HamiltonianSymbolicNeuralNetwork"><code>HamiltonianSymbolicNeuralNetwork</code></a> as the only input arguemtn, i.e.:</p><pre><code class="language-julia hljs">HNNLoss(nn)</code></pre><p>where <code>nn</code> is a <a href="#SymbolicNeuralNetworks.HamiltonianSymbolicNeuralNetwork"><code>HamiltonianSymbolicNeuralNetwork</code></a> gives the corresponding Hamiltonian loss.</p><p><strong>Funktor</strong></p><pre><code class="language-julia hljs">loss(c, ps, input, output)
loss(ps, input, output) # equivalent to the above</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/hamiltonian.jl#L53-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.HamiltonianSymbolicNeuralNetwork" href="#SymbolicNeuralNetworks.HamiltonianSymbolicNeuralNetwork"><code>SymbolicNeuralNetworks.HamiltonianSymbolicNeuralNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HamiltonianSymbolicNeuralNetwork &lt;: AbstractSymbolicNeuralNetwork</code></pre><p>A struct that inherits properties from the abstract type <code>AbstractSymbolicNeuralNetwork</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">HamiltonianSymbolicNeuralNetwork(model)</code></pre><p>Make an instance of <code>HamiltonianSymbolicNeuralNetwork</code> based on a <code>Chain</code> or an <code>Architecture</code>. This is similar to the constructor for <a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetwork</code></a> but also checks if the input dimension is even-dimensional and the output dimension is one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/hamiltonian.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.Jacobian" href="#SymbolicNeuralNetworks.Jacobian"><code>SymbolicNeuralNetworks.Jacobian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jacobian &lt;: Derivative</code></pre><p>An instance of <a href="#SymbolicNeuralNetworks.Derivative"><code>Derivative</code></a>. Computes the derivatives of a neural network with respect to its inputs.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Jacobian(output, nn)
Jacobian(nn)</code></pre><p>Compute the jacobian of a <a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetwork</code></a> with respect to the input arguments.</p><p>The output of <code>Jacobian</code> consists of a <code>NamedTuple</code> that has the following keys:</p><ol><li>a symbolic expression of the input (keyword <code>x</code>),</li><li>a symbolic expression of the output (keyword <code>soutput</code>),</li><li>a symbolic expression of the gradient (keyword <code>s∇output</code>).</li></ol><p>If <code>output</code> is not supplied as an input argument than it is taken to be:</p><pre><code class="language-julia hljs">soutput = nn.model(nn.input, nn.params)</code></pre><p><strong>Implementation</strong></p><p>For a function <span>$f:\mathbb{R}^n\to\mathbb{R}^m$</span> we choose the following convention for the Jacobian:</p><p class="math-container">\[\square_{ij} = \frac{\partial}{\partial{}x_j}f_i, \text{ i.e. } \square \in \mathbb{R}^{m\times{}n}\]</p><p>This is also used by <a href="https://github.com/FluxML/Zygote.jl"><code>Zygote</code></a> and <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff</code></a>.</p><p><strong>Examples</strong></p><p>Here we compute the Jacobian of a single-layer neural network <span>$x \to \mathrm{tanh}(Wx + b)$</span>. Its element-wise derivative is:</p><p class="math-container">\[    \frac{\partial}{\partial_i}\sigma(\sum_{k}w_{jk}x_k + b_j) = \sigma&#39;(\sum_{k}w_{jk}x_k + b_j)w_{ji}.\]</p><p>Also note that for this calculation <span>$\mathrm{tanh}(x) = \frac{e^{2x} - 1}{e^{2x} + 1}$</span> and <span>$\mathrm{tanh}&#39;(x) = \frac{4e^{2x}}{(e^{2x} + 1)^2}.$</span></p><p>We can use <code>Jacobian</code> together with <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>:</p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks
using SymbolicNeuralNetworks: Jacobian, derivative
using AbstractNeuralNetworks: Dense, Chain, initialparameters
using Symbolics
import Random

Random.seed!(123)

input_dim = 5
output_dim = 2
d = Dense(input_dim, 2, tanh)
c = Chain(d)
nn = SymbolicNeuralNetwork(c)
□ = SymbolicNeuralNetworks.Jacobian(nn)
# here we need to access the derivative and convert it into a function
jacobian1 = build_nn_function(derivative(□), nn)
ps = initialparameters(c, Float64)
input = rand(input_dim)
#derivative
Dtanh(x::Real) = 4 * exp(2 * x) / (1 + exp(2x)) ^ 2
analytic_jacobian(i, j) = Dtanh(sum(k -&gt; ps.L1.W[j, k] * input[k], 1:input_dim) + ps.L1.b[j]) * ps.L1.W[j, i]
jacobian1(input, ps) ≈ [analytic_jacobian(i, j) for j ∈ 1:output_dim, i ∈ 1:input_dim]

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/derivatives/jacobian.jl#L1-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.SymbolicNeuralNetwork" href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetworks.SymbolicNeuralNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymbolicNeuralNetwork &lt;: AbstractSymbolicNeuralNetwork</code></pre><p>A symbolic neural network realizes a symbolic represenation (of small neural networks).</p><p>The <code>struct</code> has the following fields:</p><ul><li><code>architecture</code>: the neural network architecture,</li><li><code>model</code>: the model (typically a Chain that is the realization of the architecture),</li><li><code>params</code>: the symbolic parameters of the network.</li><li><code>sinput</code>: the symbolic input of the network.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">SymbolicNeuralNetwork(arch)</code></pre><p>Make a <code>SymbolicNeuralNetwork</code> based on an architecture and a set of equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/symbolic_neuralnet.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.SymbolicPullback" href="#SymbolicNeuralNetworks.SymbolicPullback"><code>SymbolicNeuralNetworks.SymbolicPullback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymbolicPullback &lt;: AbstractPullback</code></pre><p><code>SymbolicPullback</code> computes the <em>symbolic pullback</em> of a loss function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks
using AbstractNeuralNetworks
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
loss = FeedForwardLoss()
pb = SymbolicPullback(nn, loss)
ps = initialparameters(c) |&gt; NeuralNetworkParameters
pv_values = pb(ps, nn.model, (rand(2), rand(1)))[2](1) |&gt; typeof

# output

@NamedTuple{L1::@NamedTuple{W::Matrix{Float64}, b::Vector{Float64}}}</code></pre><p><strong>Implementation</strong></p><p>An instance of <code>SymbolicPullback</code> stores</p><ul><li><code>loss</code>: an instance of a <code>NetworkLoss</code>,</li><li><code>fun</code>: a function that is used to compute the pullback.</li></ul><p>If we call the functor of an instance of <code>SymbolicPullback</code> on <code>model</code>, <code>ps</code> and <code>input</code> it returns:</p><pre><code class="language-julia hljs">_pullback.loss(model, ps, input...), _pullback.fun(input..., ps)</code></pre><p>where the second output argument is again a function.</p><p><strong>Extended help</strong></p><p>We note the following seeming peculiarity:</p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks
using AbstractNeuralNetworks
using Symbolics
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
loss = FeedForwardLoss()
pb = SymbolicPullback(nn, loss)
ps = initialparameters(c) |&gt; NeuralNetworkParameters
input_output = (rand(2), rand(1))
loss_and_pullback = pb(ps, nn.model, input_output)
pv_values = loss_and_pullback[2](1)

@variables soutput[1:SymbolicNeuralNetworks.output_dimension(nn.model)]
symbolic_pullbacks = SymbolicNeuralNetworks.symbolic_pullback(loss(nn.model, nn.params, nn.input, soutput), nn)
pv_values2 = build_nn_function(symbolic_pullbacks, nn.params, nn.input, soutput)(input_output[1], input_output[2], ps)

pv_values == (pv_values2 |&gt; SymbolicNeuralNetworks._get_params |&gt; SymbolicNeuralNetworks._get_contents)

# output

true</code></pre><p>See the docstrings for <a href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>symbolic_pullback</code></a>, <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>, <a href="#SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}"><code>_get_params</code></a> and <a href="#SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}"><code>_get_contents</code></a> for more info on the functions that we used here. The noteworthy thing in the expression above is that the functor of <code>SymbolicPullback</code> returns two objects: the first one is the loss value evaluated for the relevant parameters and inputs. The second one is a function that takes again an input argument and then finally returns the partial derivatives. But why do we need this extra step with another function?</p><div class="admonition is-info"><header class="admonition-header">Reverse Accumulation</header><div class="admonition-body"><p>In machine learning we typically do <a href="https://en.wikipedia.org/wiki/Automatic_differentiation#Forward_and_reverse_accumulation">reverse accumulation</a> to perform automatic differentiation (AD). Assuming we are given a function that is the composition of simpler functions <span>$f = f_1\circ{}f_2\circ\cdots\circ{}f_n:\mathbb{R}^n\to\mathbb{R}^m$</span> <em>reverse differentiation</em> starts with <em>output sensitivities</em> and then successively feeds them through <span>$f_n$</span>, <span>$f_{n-1}$</span> etc. So it does:</p><p class="math-container">\[(\nabla_xf)^T = (\nabla_{x}f_1)^T(\nabla_{f_1(x)}f_2)^T\cdots(\nabla_{f_{n-1}(\cdots{}x)}f_n)^T(do),\]</p><p>where <span>$do\in\mathbb{R}^m$</span> are the <em>output sensitivities</em> and the jacobians are stepwise multiplied from the left. So we propagate from the output stepwise back to the input. If we have <span>$m=1$</span>, i.e. if the output is one-dimensional, then the <em>output sensitivities</em> may simply be taken to be <span>$do = 1$</span>.</p></div></div><p>So in theory we could leave out this extra step: returning an object (that is stored in <code>pb.fun</code>) can be seen as unnecessary as we could simply store the equivalent of <code>pb.fun(1.)</code> in an instance of <code>SymbolicPullback</code>. It is however customary for a pullback to return a callable function (that depends on the <em>output sensitivities</em>), which is why we also choose to do this here, even if the <em>output sensitivities</em> are a scalar quantity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/pullback.jl#L1-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}" href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_build_nn_function(eq, params, sinput, soutput)</code></pre><p>Build a function that can process a matrix. See <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr)</code></a>.</p><p><strong>Implementation</strong></p><p>Note that we have two input arguments here which means this method processes code differently than <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr, ::Symbolics.Arr)</code></a>. Here we call:</p><ol><li><a href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>fix_create_array</code></a>,</li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}"><code>rewrite_arguments2</code></a>,</li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}"><code>modify_input_arguments2</code></a>,</li><li><a href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>fix_map_reduce</code></a>.</li></ol><p>See the docstrings for those functions for details on how the code is modified. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function2.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}" href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_build_nn_function(eq, params, sinput)</code></pre><p>Build a function that can process a matrix. This is used as a starting point for <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _build_nn_function, symbolicparameters
using Symbolics
using AbstractNeuralNetworks

c = Chain(Dense(2, 1, tanh))
params = symbolicparameters(c)
@variables sinput[1:2]
eq = c(sinput, params)
built_function = _build_nn_function(eq, params, sinput)
ps = initialparameters(c)
input = rand(2, 2)

(built_function(input, ps, 1), built_function(input, ps, 2)) .≈ (c(input[:, 1], ps), c(input[:, 2], ps))

# output

(true, true)</code></pre><p><strong>Implementation</strong></p><p>This first calls <code>Symbolics.build_function</code> with the keyword argument <code>expression = Val{true}</code> and then modifies the generated code by calling:</p><ol><li><a href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>fix_create_array</code></a>,</li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>,</li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}"><code>modify_input_arguments</code></a>,</li><li><a href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>fix_map_reduce</code></a>.</li></ol><p>See the docstrings for those functions for details on how the code is modified. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L34-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}" href="#SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_contents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_contents(nt::AbstractArray{&lt;:NamedTuple})</code></pre><p>Return the contents of a one-dimensional vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _get_contents

_get_contents([(a = &quot;element_contained_in_vector&quot;, )])

# output

(a = &quot;element_contained_in_vector&quot;,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/pullback.jl#L115-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}" href="#SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_params(ps::NeuralNetworkParameters)</code></pre><p>Return the <code>NamedTuple</code> that&#39;s equivalent to the <code>NeuralNetworkParameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/pullback.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}" href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_modify_integer</code></pre><p>If the input is a single integer, subtract 1 from it.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _modify_integer

s = [&quot;2&quot;, &quot;hello&quot;, &quot;hello2&quot;, &quot;3&quot;]
_modify_integer.(s)

# output
4-element Vector{String}:
 &quot;1&quot;
 &quot;hello&quot;
 &quot;hello2&quot;
 &quot;2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L134-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_modify_integer2</code></pre><p>If the input is a single integer, subtract 2 from it.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _modify_integer2

s = [&quot;3&quot;, &quot;hello&quot;, &quot;hello2&quot;, &quot;4&quot;]
_modify_integer2.(s)

# output
4-element Vector{String}:
 &quot;1&quot;
 &quot;hello&quot;
 &quot;hello2&quot;
 &quot;2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function2.jl#L140-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._reduce_code-Tuple{Expr}" href="#SymbolicNeuralNetworks._reduce_code-Tuple{Expr}"><code>SymbolicNeuralNetworks._reduce_code</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_reduce_code(code)</code></pre><p>Reduce the code.</p><p>For some reason <code>Symbolics.build_function</code> sometimes returns a tuple and sometimes it doesn&#39;t.</p><p>This function takes care of this.  If <code>build_function</code> returns a tuple <code>reduce_code</code> checks which of the expressions is in-place and then returns the other (not in-place) expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}" href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_element_wise(ps, params, input...)</code></pre><p>Apply a function element-wise. <code>ps</code> is an <code>Array</code> where each entry of the array is are <code>NeuralNetworkParameters</code> that store functions. See <a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}"><code>apply_element_wise(::NeuralNetworkParameters, ::NeuralNetworkParameters, ::Any)</code></a>.</p><p><strong>Examples</strong></p><p>Vector: </p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: apply_element_wise
using AbstractNeuralNetworks: NeuralNetworkParameters

# parameter values
params = NeuralNetworkParameters((a = 1., b = 2.))
ps = [NeuralNetworkParameters((val1 = (input, params) -&gt; input .+ params.a, val2 = (input, params) -&gt; input .+ params.b))]
apply_element_wise(ps, params, [1.])

# output

1-element Vector{NeuralNetworkParameters{(:val1, :val2), Tuple{Vector{Float64}, Vector{Float64}}}}:
 NeuralNetworkParameters{(:val1, :val2), Tuple{Vector{Float64}, Vector{Float64}}}((val1 = [2.0], val2 = [3.0]))</code></pre><p>Matrix: </p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: apply_element_wise
using AbstractNeuralNetworks: NeuralNetworkParameters

# parameter values
params = NeuralNetworkParameters((a = 1., b = 2.))
sc_ps = NeuralNetworkParameters((val1 = (input, params) -&gt; input .+ params.a, val2 = (input, params) -&gt; input .+ params.b))
ps = [sc_ps sc_ps]
apply_element_wise(ps, params, [1.]) |&gt; typeof

# output

Matrix{NeuralNetworkParameters{(:val1, :val2), Tuple{Vector{Float64}, Vector{Float64}}}} (alias for Array{NeuralNetworkParameters{(:val1, :val2), Tuple{Array{Float64, 1}, Array{Float64, 1}}}, 2})</code></pre><p><strong>Implementation</strong></p><p>This is generating a <code>@generated function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function_arrays.jl#L123-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}" href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_element_wise(ps, params, input...)</code></pre><p>Apply a function element-wise. <code>ps</code> is a <code>NeuralNetworkParameters</code>-valued function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: apply_element_wise
using AbstractNeuralNetworks: NeuralNetworkParameters

# parameter values
params = NeuralNetworkParameters((a = 1., b = 2.))
ps = NeuralNetworkParameters((val1 = (input, params) -&gt; input + params.a, val2 = (input, params) -&gt; input + params.b))
apply_element_wise(ps, params, 1.)

# output

NeuralNetworkParameters{(:val1, :val2), Tuple{Float64, Float64}}((val1 = 2.0, val2 = 3.0))</code></pre><p><strong>Implementation</strong></p><p>This is generating a <code>@generated function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function_arrays.jl#L215-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eqs::AbstractArray{&lt;:NeuralNetworkParameters}, sparams, sinput...)</code></pre><p>Build an executable function based on <code>eqs</code> that potentially also has a symbolic output.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: build_nn_function, SymbolicNeuralNetwork
using AbstractNeuralNetworks: Chain, Dense, initialparameters, NeuralNetworkParameters
import Random
Random.seed!(123)

ch = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(ch)
eqs = [(a = ch(nn.input, nn.params), b = ch(nn.input, nn.params).^2), (c = ch(nn.input, nn.params).^3, )]
funcs = build_nn_function(eqs, nn.params, nn.input)
input = [1., 2.]
ps = initialparameters(ch) |&gt; NeuralNetworkParameters
a = ch(input, ps)
b = ch(input, ps).^2
c = ch(input, ps).^3
funcs_evaluated = funcs(input, ps)

(funcs_evaluated[1].a, funcs_evaluated[1].b, funcs_evaluated[2].c) .≈ (a, b, c)

# output

(true, true, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function_arrays.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{Any, AbstractSymbolicNeuralNetwork, Any}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Any, AbstractSymbolicNeuralNetwork, Any}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eqs, nn, soutput)</code></pre><p>Build an executable function that can also depend on an output. It is then called with:</p><pre><code class="language-julia hljs">built_function(input, output, ps)</code></pre><p>Also compare this to <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>build_nn_function(::EqT, ::AbstractSymbolicNeuralNetwork)</code></a>.</p><p><strong>Extended Help</strong></p><p>See the <em>extended help section</em> of <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>build_nn_function(::EqT, ::AbstractSymbolicNeuralNetwork)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function2.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eqs::Union{NamedTuple, NeuralNetworkParameters}, sparams, sinput...)</code></pre><p>Return a function that takes an input, (optionally) an output and neural network parameters and returns a <code>NeuralNetworkParameters</code>-valued output.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: build_nn_function, SymbolicNeuralNetwork
using AbstractNeuralNetworks: Chain, Dense, initialparameters, NeuralNetworkParameters
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
eqs = (a = c(nn.input, nn.params), b = c(nn.input, nn.params).^2)
funcs = build_nn_function(eqs, nn.params, nn.input)
input = [1., 2.]
ps = initialparameters(c) |&gt; NeuralNetworkParameters
a = c(input, ps)
b = c(input, ps).^2
funcs_evaluated = funcs(input, ps)

(funcs_evaluated.a, funcs_evaluated.b) .≈ (a, b)

# output

(true, true)</code></pre><p><strong>Implementation</strong></p><p>Internally this is using <a href="#SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>function_valued_parameters</code></a> and <a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>apply_element_wise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function_arrays.jl#L41-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eq, nn)</code></pre><p>Build an executable function based on a symbolic equation, a symbolic input array and a <a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetwork</code></a>.</p><p>This function can be called with:</p><pre><code class="language-julia hljs">built_function(input, ps)</code></pre><p><strong>Implementation</strong></p><p>Internally this is calling <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function</code></a> and then <em>parallelizing</em> the expression via the index <code>k</code>.</p><p><strong>Extended Help</strong></p><p>The functions mentioned in the implementation section were adjusted ad-hoc to deal with problems that emerged on the fly.  Other problems may occur. In case you bump into one please <a href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/issues">open an issue on github</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.derivative-Tuple{SymbolicNeuralNetworks.Gradient}" href="#SymbolicNeuralNetworks.derivative-Tuple{SymbolicNeuralNetworks.Gradient}"><code>SymbolicNeuralNetworks.derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative(g)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: SymbolicNeuralNetwork, Gradient, derivative, symbolic_pullback
using AbstractNeuralNetworks

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
g = Gradient(nn)
∇ = derivative(g)

isequal(∇, symbolic_pullback(g.output, nn))

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/derivatives/gradient.jl#L49-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.evaluate_equation-NTuple{5, Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}}" href="#SymbolicNeuralNetworks.evaluate_equation-NTuple{5, Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}}"><code>SymbolicNeuralNetworks.evaluate_equation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_equation(eq, soutput)</code></pre><p>Replace <code>snn</code> in <code>eq</code> with <code>soutput</code> (input), scalarize and expand derivatives.</p><p><strong>Implementation</strong></p><p>Here we use <code>Symbolics.substitute</code> with broadcasting to be able to handle <code>eq</code>s that are arrays. For that reason we use <a href="https://discourse.julialang.org/t/symbolics-and-substitution-using-broadcasting/68705"><code>Ref</code> before <code>Dict</code></a>. This is also the case for the functions <a href="#SymbolicNeuralNetworks.substitute_gradient-Tuple{Any, Any, Any}"><code>substitute_gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/custom_equation.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.evaluate_equations-Tuple{NamedTuple, AbstractSymbolicNeuralNetwork}" href="#SymbolicNeuralNetworks.evaluate_equations-Tuple{NamedTuple, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.evaluate_equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_equations(eqs, nn)</code></pre><p>Expand the output and gradient in <code>eqs</code> with the weights in <code>nn</code>.</p><ul><li><code>eqs</code> here has to be a <code>NamedTuple</code> that contains keys </li><li><code>:x</code>: gives the inputs to the neural network and </li><li><code>:nn</code>: symbolic expression of the neural network.</li></ul><p><strong>Implementation</strong></p><p>Internally this </p><ol><li>computes the gradient and</li><li>calls <a href="#SymbolicNeuralNetworks.evaluate_equations-Tuple{NamedTuple, AbstractSymbolicNeuralNetwork}"><code>evaluate_equations(::NamedTuple, ::EqT, ::EqT, ::EqT, EqT)</code></a>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/custom_equation.jl#L52-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.evaluate_equations-Tuple{NamedTuple, Vararg{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, 4}}" href="#SymbolicNeuralNetworks.evaluate_equations-Tuple{NamedTuple, Vararg{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, 4}}"><code>SymbolicNeuralNetworks.evaluate_equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_equations(eqs, soutput)</code></pre><p>Apply <a href="#SymbolicNeuralNetworks.evaluate_equation-NTuple{5, Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}}"><code>evaluate_equation</code></a> to a <code>NamedTuple</code> and append <code>(soutput = soutput, s∇output = s∇output)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/custom_equation.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_create_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>fix<em>create</em>array(s)</p><p>Fix a problem that occurs in connection with <code>create_array</code>.</p><p>The function <code>create_array</code> from <code>SymbolicUtils.Code</code> takes as first input the type of a symbolic array.  For reasons that are not entirely clear yet the first argument of <code>create_array</code> ends up being <code>ˍ₋arg2</code>, which is a <code>NamedTuple</code> of symoblic arrays. We solve this problem by replacing <code>typeof(ˍ₋arg[0-9]+)</code> with <code>Array</code>, which seems to be the most generic possible input to <code>create_array</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: fix_create_array

s = &quot;(SymbolicUtils.Code.create_array)(typeof(ˍ₋arg2)&quot;
fix_create_array(s)

# output

&quot;SymbolicUtils.Code.create_array(typeof(sinput)&quot;</code></pre><p><strong>Implementation</strong></p><p>This is used for <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr)</code></a> and <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr, ::Symbolics.Arr)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L187-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_map_reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_map_reduce(s)</code></pre><p>Replace <code>Symbolics._mapreduce</code> with <code>mapreduce</code> (from <code>Base</code>).</p><p>When we generate a function with <code>Symbolics.build_function</code> it often contains <code>Symbolics._mapreduce</code> which cannot be differentiated with Zygote.  We get around this by replacing <code>Symbolics._mapreduce</code> with <code>mapreduce</code> and also doing:</p><pre><code class="language-julia hljs">replace(s, &quot;, Colon(), (:init =&gt; false,)&quot; =&gt; &quot;, dims = Colon()&quot;)</code></pre><p><strong>Implementation</strong></p><p>This is used for <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr)</code></a> and <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr, ::Symbolics.Arr)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L223-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}" href="#SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.function_valued_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function_valued_parameters(eqs::Union{NamedTuple, NeuralNetworkParameters}, sparams, sinput...)</code></pre><p>Return an executable function for each entry in <code>eqs</code>. This still has to be processed with <a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>apply_element_wise</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: function_valued_parameters, SymbolicNeuralNetwork
using AbstractNeuralNetworks: Chain, Dense, initialparameters, NeuralNetworkParameters
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
eqs = (a = c(nn.input, nn.params), b = c(nn.input, nn.params).^2)
funcs = function_valued_parameters(eqs, nn.params, nn.input)
input = [1., 2.]
ps = initialparameters(c) |&gt; NeuralNetworkParameters
a = c(input, ps)
b = c(input, ps).^2

(funcs.a(input, ps), funcs.b(input, ps)) .≈ (a, b)

# output

(true, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function_arrays.jl#L84-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.make_kernel-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.make_kernel-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks

s = &quot;function (sinput, ps)\n begin\n getindex(sinput, 1) + getindex(sinput, 2) \n end\n end&quot;
SymbolicNeuralNetworks.make_kernel(s)

# output

&quot;function (sinput, ps, k)\n begin\n getindex(sinput, 1, k) + getindex(sinput, 2, k) \n end\n end&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L247-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.make_kernel2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.make_kernel2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks

s = &quot;function (sinput, soutput, ps)\n begin\n getindex(sinput, 1) + getindex(soutput, 2) \n end\n end&quot;
SymbolicNeuralNetworks.make_kernel2(s)

# output

&quot;function (sinput, soutput, ps, k)\n begin\n getindex(sinput, 1, k) + getindex(soutput, 2, k) \n end\n end&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function2.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modify_input_arguments(s)</code></pre><p>Change input arguments of type <code>(sinput, ps.L1, ps.L2)</code> etc to <code>(sinput, ps)</code>. This should be used after <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>. Also see <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: modify_input_arguments

s = &quot;(sinput, ps.L1, ps.L2, ps.L3)&quot;
modify_input_arguments(s)

# output
&quot;(sinput, ps)&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L159-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modify_input_arguments2(s)</code></pre><p>Change input arguments of type <code>(sinput, soutput, ps.L1, ps.L2)</code> etc to <code>(sinput, soutput, ps)</code>. This should be used after <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: modify_input_arguments2

s = &quot;(sinput, soutput, ps.L1, ps.L2, ps.L3)&quot;
modify_input_arguments2(s)

# output
&quot;(sinput, soutput, ps)&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function2.jl#L51-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_arguments(s)</code></pre><p>Replace <code>ˍ₋arg2</code>, <code>ˍ₋arg3</code>, ... with <code>ps.L1</code>, <code>ps.L2</code> etc. This is used after <code>Symbolics.build_function</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: rewrite_arguments
s = &quot;We test if strings that contain ˍ₋arg2 and ˍ₋arg3 can be converted in the right way.&quot;
rewrite_arguments(s)

# output
&quot;We test if strings that contain ps.L1 and ps.L2 can be converted in the right way.&quot;</code></pre><p><strong>Implementation</strong></p><p>The input is first split at the relevant points and then we call <a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>_modify_integer</code></a>. The routine <a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>_modify_integer</code></a> ensures that we start counting at 1 and not at 2. By defaut the arguments of the generated function that we get after applying <code>Symbolics.build_function</code> are <code>(x, ˍ₋arg2, ˍ₋arg3)</code> etc. We first change this to <code>(x, ps.L2, ps.L3)</code> etc. and then to <code>(x, ps.L1, ps.L2)</code> etc. via <a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>_modify_integer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function.jl#L97-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_arguments2(s)</code></pre><p>Replace <code>ˍ₋arg3</code>, <code>ˍ₋arg4</code>, ... with <code>ps.L1</code>, <code>ps.L2</code> etc. Note that we subtract two from the input, unlike <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a> where it is one.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: rewrite_arguments2
s = &quot;We test if strings that contain ˍ₋arg3 and ˍ₋arg4 can be converted in the right way.&quot;
rewrite_arguments2(s)

# output
&quot;We test if strings that contain ps.L1 and ps.L2 can be converted in the right way.&quot;</code></pre><p><strong>Implementation</strong></p><p>The input is first split at the relevant points and then we call <a href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>_modify_integer2</code></a>. The routine <a href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>_modify_integer2</code></a> ensures that we start counting at 1 and not at 3. See <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/utils/build_function2.jl#L104-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.substitute_gradient-Tuple{Any, Any, Any}" href="#SymbolicNeuralNetworks.substitute_gradient-Tuple{Any, Any, Any}"><code>SymbolicNeuralNetworks.substitute_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">substitute_gradient(eq, s∇nn, s∇output)</code></pre><p>Substitute the symbolic expression <code>s∇nn</code> in <code>eq</code> with the symbolic expression <code>s∇output</code>.</p><p><strong>Implementation</strong></p><p>See the comment in <a href="#SymbolicNeuralNetworks.evaluate_equation-NTuple{5, Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}}"><code>evaluate_equation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/custom_equation.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}" href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.symbolic_pullback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolic_pullback(nn, output)</code></pre><p>This takes a symbolic output that depends on the parameters in <code>nn</code> and returns the corresponding pullback (a symbolic expression).</p><p>This is used by <a href="#SymbolicNeuralNetworks.Gradient"><code>Gradient</code></a> and <a href="#SymbolicNeuralNetworks.SymbolicPullback"><code>SymbolicPullback</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: SymbolicNeuralNetwork, symbolic_pullback
using AbstractNeuralNetworks
using LinearAlgebra: norm
using Latexify: latexify

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
output = c(nn.input, nn.params)
spb = symbolic_pullback(output, nn)

spb[1].L1.b |&gt; latexify

# output

L&quot;\begin{equation}
\left[
\begin{array}{c}
1 - \tanh^{2}\left( \mathtt{b\_1}_{1} + \mathtt{W\_1}_{1,1} \mathtt{sinput}_{1} + \mathtt{W\_1}_{1,2} \mathtt{sinput}_{2} \right) \\
\end{array}
\right]
\end{equation}
&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/derivatives/gradient.jl#L81-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.symbolicparameters-Tuple{AbstractNeuralNetworks.Model}" href="#SymbolicNeuralNetworks.symbolicparameters-Tuple{AbstractNeuralNetworks.Model}"><code>SymbolicNeuralNetworks.symbolicparameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolicparameters(model)</code></pre><p>Obtain the symbolic parameters of a neural network model.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks
using AbstractNeuralNetworks

d = Dense(4, 5, tanh)
symbolicparameters(d) |&gt; typeof

# output

@NamedTuple{W::Symbolics.Arr{Symbolics.Num, 2}, b::Symbolics.Arr{Symbolics.Num, 1}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/layers/abstract.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.vector_field-Tuple{HamiltonianSymbolicNeuralNetwork}" href="#SymbolicNeuralNetworks.vector_field-Tuple{HamiltonianSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.vector_field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_field(nn::HamiltonianSymbolicNeuralNetwork)</code></pre><p>Get the symbolic expression for the vector field belonging to the HNN <code>nn</code>.</p><p><strong>Implementation</strong></p><p>This is calling <a href="#SymbolicNeuralNetworks.Jacobian"><code>SymbolicNeuralNetworks.Jacobian</code></a> and then multiplies the result with a Poisson tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/8d610cc0cfa20b2486a7b2b26734d9987b13fc37/src/hamiltonian.jl#L30-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="symbolic_neural_networks/">Vanilla Symbolic Neural Network »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 4 December 2024 08:33">Wednesday 4 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
